import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { IMaterial, IPass, IShaderPropertiesUpdater } from 'webgi/interfaces';
import { BufferGeometry, Camera, ColorSpace, IUniform, Object3D, Scene, Shader, ShaderMaterial, ShaderMaterialParameters, WebGLMultipleRenderTargets, WebGLRenderer, WebGLRenderTarget } from 'three';
import { MaterialExtension } from 'webgi/extras/asset_manager/threejs/MaterialExtender';
import { AnyOptions } from 'ts-browser-helpers';
export declare abstract class AShaderMaterial2 extends ShaderMaterial implements IMaterial {
    readonly typeSlug: string;
    assetType: 'material';
    materialObject: this;
    materialExtensions: MaterialExtension[];
    isRawShaderMaterial: boolean;
    constructor(parameters?: any & {
        customMaterialExtensions?: MaterialExtension[];
    }, isRawShaderMaterial?: boolean);
    registerMaterialExtensions(customMaterialExtensions: MaterialExtension[]): void;
    unregisterMaterialExtensions(customMaterialExtensions: MaterialExtension[]): void;
    onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
    customProgramCacheKey(): string;
    extraUniformsToUpload: Record<string, IUniform>;
    onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    onAfterRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    abstract toJSON(meta?: any): any;
    abstract fromJSON(data: any, meta?: any): this | null;
    abstract copyProps(oldMaterial: any): this;
    setDirty(options?: AnyOptions): void;
}
export declare class ShaderMaterial2 extends AShaderMaterial2 implements IMaterial {
    readonly typeSlug: string;
    toJSON(meta?: any): any;
    fromJSON(data: any, meta?: any): this | null;
    copyProps(oldMaterial: any): this;
}
export declare class ShaderMaterialEncodingSupport extends ShaderMaterial2 {
    readonly typeSlug = "shaderMat";
    textures: {
        colorSpace: ColorSpace;
        id: string;
    }[];
    constructor(parameters: ShaderMaterialParameters, textureIds: string[]);
    setTextureIds(ids: string[]): void;
    private _setUniformTexSize;
    onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    onBeforeCompile(s: Shader, renderer: WebGLRenderer): void;
    customProgramCacheKey(): string;
}
export declare function patchShaderEncodingSupport(shader: any, ...textureIds: string[]): ShaderMaterialEncodingSupport;
export declare class ShaderPass2 extends ShaderPass implements IPass {
    onDirty: (() => void)[];
    static readonly DEFAULT_TEX_ID = "tDiffuse";
    material: ShaderMaterial2;
    isShaderPass2: boolean;
    enabled: boolean;
    constructor(shader: Shader | any, ...textureID: string[]);
    dispose(): void;
    setDirty(): void;
    updateShaderProperties(updater?: (IShaderPropertiesUpdater | undefined) | (IShaderPropertiesUpdater | undefined)[]): void;
    render(renderer: WebGLRenderer, writeBuffer: WebGLMultipleRenderTargets | WebGLRenderTarget | null, readBuffer?: WebGLMultipleRenderTargets | WebGLRenderTarget, deltaTime?: number, maskActive?: boolean): void;
}
//# sourceMappingURL=ShaderPass2.d.ts.map