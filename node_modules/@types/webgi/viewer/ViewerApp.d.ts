import { AnyOptions, Class, IEvent, SimpleEventDispatcher } from 'ts-browser-helpers';
import { IFilter, IMaterial, IModel, ISceneObject, ITexture, IViewerApp, IViewerPlugin, IViewerPluginSync, ViewerState } from 'webgi/interfaces';
import { BaseRenderer } from 'webgi/core/threejs/BaseRenderer';
import { RootScene } from 'webgi/core/threejs/RootScene';
import { CameraController } from 'webgi/core/threejs/CameraController';
import { Material, MeshPhysicalMaterialParameters, Object3D, OrthographicCamera, PerspectiveCamera, Texture } from 'three';
import { ShaderPass2 } from 'webgi/passes/threejs/ShaderPass2';
import { RenderPass2 } from 'webgi/passes/threejs/RenderPass2';
import { Color } from 'three/src/math/Color';
import { AssetManagerOptions, AssetManagerPlugin, ImportAddOptions } from 'webgi/extras/asset_manager/AssetManagerPlugin';
import { Object3DModel } from 'webgi/core/threejs/Object3DModel';
import { MeshStandardMaterial2 } from 'webgi/extras/asset_manager/threejs/MeshStandardMaterial2';
import { Easing } from 'popmotion';
import { EasingFunctionType } from 'webgi/helpers/animation';
import { IAsset, ImportAssetOptions } from 'webgi/extras/asset_manager/AssetManager';
export type TViewerScreenShaderFrag = string | [string, string] | {
    pars?: string;
    main: string;
};
export type TViewerScreenShader = TViewerScreenShaderFrag | ShaderPass2;
/**
 * Options for the ViewerApp creation.
 */
export interface IViewerAppOptions {
    /**
     * The canvas element to use for rendering.
     */
    canvas?: HTMLCanvasElement;
    /**
     * The container for the canvas. Only one of container and canvas must be specified.
     */
    container?: HTMLElement;
    /**
     * The fragment shader snippet to render on screen.
     * not used with TonemapPlugin
     */
    screenShader?: TViewerScreenShader;
    /**
     * Use MSAA. Not supported yet
     */
    isAntialiased?: boolean;
    /**
     * Use RGBM HDR Pipeline
     */
    useRgbm?: boolean;
    /**
     * Use rendered gbuffer as depth-prepass.
     */
    useGBufferDepth?: boolean;
    /**
     * Options for the asset manager plugin.
     * If set to false, the asset manager plugin will not be added.
     */
    assetManager?: AssetManagerOptions | boolean;
    /**
     * Toggle for the Dropzone Plugin, will be added if set to true.
     */
    dropzone?: boolean;
}
/**
 * @licence
 * A WebGi SDK is built and maintained by @repalash at Pixotronics, a license needs to be purchased from Pixotronics for any commercial use.
 * For more details check: https://webgi.xyz/docs/license/
 * For End User License Agreement (EULA) see: https://webgi.xyz/eula/
 * Please read the license agreement before using the WebGi SDK or a part of it in your website or application.
 */
/**
 * The main entry point for the 3D viewer SDK. Creates a scene, renderer and attaches itself to a canvas.
 */
export declare class ViewerApp extends SimpleEventDispatcher<'update' | 'preRender' | 'postRender' | 'preFrame' | 'postFrame' | 'dispose' | 'addPlugin' | 'renderEnabled' | 'renderDisabled'> implements IViewerApp {
    static readonly VERSION = "0.8.5";
    console: Console;
    private _canvas;
    private _container;
    private _state;
    private readonly _renderer;
    /**
     * The Scene attached to the viewer, this cannot be changed.
     * @type {RootScene}
     */
    readonly scene: RootScene;
    /**
     * Use RGBM HDR Pipeline for rendering, which makes it faster on smaller devices but disables some features like transparency.
     * @returns {boolean}
     */
    get useRgbm(): boolean;
    /**
     * Screen shader used for final rendering on screen, this can be used by other plugins to render on screen like TonemapPlugin. so it's readonly.
     * @returns {TViewerScreenShader}
     */
    get screenShader(): TViewerScreenShader;
    readonly plugins: Record<string, IViewerPlugin>;
    private _needsResize;
    private _useRgbm;
    private _screenShader;
    /**
     * The IFilter wrapper for the main render pass for the effect composer.
     * @type {IFilter<RenderPass2, "render">}
     */
    readonly renderFilter: IFilter<RenderPass2, 'render'>;
    /**
     * Whether to use the rendered gbuffer as depth-prepass. Requires GBufferPlugin This gives performance improvements but sometimes creates issues with z-fighting
     * @returns {boolean}
     */
    get useGBufferDepth(): boolean;
    private _useGBufferDepth;
    /**
     * Whether using Multisample render targets for rendering.
     * @returns {boolean}
     */
    get isAntialiased(): boolean;
    private _isAntialiased;
    /**
     * The ResizeObserver observing the canvas element. Add more elements to this observer to resize viewer on their size change.
     * @type {ResizeObserver | undefined}
     */
    readonly resizeObserver: ResizeObserver | undefined;
    /**
     * Create a viewer instance for using the webgi viewer SDK.
     * @param isAntialiased - Use MSAA.
     * @param useRgbm - Use RGBM HDR Pipeline for rendering, which makes it faster on smaller devices but disables some features like transparency.
     * @param useGBufferDepth - requires GBufferPlugin
     * @param screenShader - The shader to use for rendering on screen. (default is Gamma correction shader)
     * @param options - {@see IViewerAppOptions}
     */
    constructor({ isAntialiased, useRgbm, useGBufferDepth, // requires GBufferPlugin
    screenShader, ...options }: IViewerAppOptions);
    private _lastSize;
    private _onContextRestore;
    private _onContextLost;
    /**
     * Mark that the canvas is resized. If the size is changed, the renderer and all render targets are resized. This happens before the render of the next frame.
     */
    resize: () => void;
    private _needsReset;
    /**
     * Set the viewer to dirty and trigger render of the next frame.
     * @param source - The source of the dirty event. like plugin or 3d object
     * @param event - The event that triggered the dirty event.
     */
    setDirty(source?: any, event?: IEvent<any>): void;
    /**
     * The renderer for the viewer that's attached to the canvas. This is wrapper around WebGLRenderer and EffectComposer and manages post-processing passes and rendering logic
     * @returns {BaseRenderer}
     */
    get renderer(): BaseRenderer;
    /**
     * Disposes the viewer and frees up all resource and events. Do not use the viewer after calling dispose.
     * @note - If you want to reuse the viewer, set viewer.enabled to false instead, then set it to true again when required. To dispose all the objects, materials in the scene use `viewer.scene.disposeSceneModels()`
     * This function is not fully implemented yet. There might be some memory leaks.
     */
    dispose(): void;
    /**
     * If the viewer is enabled. Set this `false` to disable RAF loop.
     * @type {boolean}
     */
    enabled: boolean;
    /**
     * Enable or disable all rendering, Animation loop including any frame/render events won't be fired when this is false.
     */
    renderEnabled: boolean;
    private _renderEnabledChanged;
    private _isRenderingFrame;
    /**
     * Specifies how many frames to render in a single request animation frame. Keep to 1 for realtime rendering.
     * Note: should be max (screen refresh rate / animation frame rate) like 60Hz / 30fps
     * @type {number}
     */
    maxFramePerLoop: number;
    private _animationLoop;
    /**
     * @deprecated
     * State of the viewer. Not implemented.
     * @see ViewerApp.enabled.
     * @returns {ViewerState}
     */
    get state(): ViewerState;
    /**
     * Get the HTML Element containing the canvas
     * @returns {HTMLElement}
     */
    get container(): HTMLElement;
    /**
     * Get the HTML Canvas Element where the viewer is rendering
     * @returns {HTMLCanvasElement}
     */
    get canvas(): HTMLCanvasElement;
    /**
     * Get the Plugin by a type.
     * @param type - The class of the plugin to get.
     * @returns {T | undefined} - The plugin of the specified type.
     */
    getPlugin<T extends IViewerPlugin>(type: Class<T> | string): T | undefined;
    /**
     * Get the Plugin by the string type. Use this function if the plugin is not a dependency and you don't want to bundle the plugin.
     * @param type - The string type of the plugin to get. This in the static PluginType property of the plugin
     * @returns {T | undefined}
     */
    getPluginByType<T extends IViewerPlugin<ViewerApp>>(type: string): T | undefined;
    getOrAddPlugin<T extends IViewerPlugin>(type: Class<T>, ...args: ConstructorParameters<Class<T>>): Promise<T>;
    getOrAddPluginSync<T extends IViewerPluginSync>(type: Class<T>, ...args: ConstructorParameters<Class<T>>): T;
    /**
     * Add a plugin to the viewer.
     * @param plugin - The instance of the plugin to add or the class of the plugin to add.
     * @param args - Arguments for the constructor of the plugin, in case a class is passed.
     * @returns {Promise<T>} - The plugin added.
     */
    addPlugin<T extends IViewerPlugin>(plugin: T | Class<T>, ...args: ConstructorParameters<Class<T>>): Promise<T>;
    /**
     * Add a plugin to the viewer(sync).
     * @param plugin
     * @param args
     */
    addPluginSync<T extends IViewerPluginSync>(plugin: T | Class<T>, ...args: ConstructorParameters<Class<T>>): T;
    addPlugins(plugins: (IViewerPlugin | Class<IViewerPlugin>)[]): Promise<void>;
    addPluginsSync(plugins: (IViewerPluginSync | Class<IViewerPluginSync>)[]): Promise<void>;
    /**
     * Remove a plugin instance or a plugin class. Works similar to {@see ViewerApp.addPlugin}
     * @param p
     * @param dispose
     * @returns {Promise<void>}
     */
    removePlugin(p: IViewerPlugin, dispose?: boolean): Promise<void>;
    removePluginSync(p: IViewerPluginSync, dispose?: boolean): void;
    /**
     * Converts a three.js Camera instance to be used in the viewer.
     * @param camera - The three.js OrthographicCamera or PerspectiveCamera instance
     * @returns {CameraController} - A wrapper around the camera with some useful methods and properties.
     */
    createCamera(camera: OrthographicCamera | PerspectiveCamera): CameraController;
    /**
     * Set size of the canvas and update the renderer.
     * If no width/height is passed, canvas is set to 100% of the container.
     * @param size
     */
    setSize(size?: {
        width?: number;
        height?: number;
    }): void;
    /**
     * @deprecated
     */
    private _rawBackground;
    /**
     * Intensity for the background color or image. This can be set to more than 1 with RGB workflows. This scales the RGB color values, but not the alpha. Hence, 0 is black. not transparent.
     * @type {number}
     */
    /**
     * Set to false for Physically Correct Lighting, see useLegacyLights in three.js
     */
    private _sceneEnvironmentChanged;
    doOnce<TRet>(event: 'postFrame' | 'preFrame' | 'preRender' | 'postRender' | 'renderEnabled' | 'renderDisabled', func: (...args: any[]) => TRet): Promise<TRet>;
    private _addSceneObject;
    /**
     * Set the background color.
     * @deprecated use {@see RootScene.setBackgroundColor} instead.
     * @param color - color in sRGB space.
     */
    setBackgroundColor(color: string | number | Color): void;
    /**
     * Set the background color or texture, toggle it to show the environment as the background. This function is async because the background can be processed by some plugins after setting. This assumes the color to be in the Linear RGB color space, to use with sRGB use function {@see setBackgroundColor}.
     * @deprecated use {@see RootScene.setBackground} instead.
     * @param asset - a Texture object, or a string/number/Color to set a solid color or {@see envMapBackground} for showing the scene environment map
     * @returns {void} - returns after background is set.
     */
    setBackground(asset: ITexture | string | number | null | Color | EnvMapBackground): void;
    /**
     * Get the background color or texture for the scene.
     * @param raw - if true, returns the raw value that was passed to {@see setBackground}, otherwise returns the computed value. (eg. with RGBM, colors are converted to 1px textures, when raw is false, the texture is returned, else the raw color value that was set.)
     * @returns {any}
     */
    getBackground(raw?: boolean): ITexture | string | number | null;
    /**
     * Gets the Asset management plugin, contains useful functions for managing, loading and inserting assets.
     * @returns {AssetManagerPlugin | undefined}
     */
    getManager(): AssetManagerPlugin | undefined;
    /**
     * Sets the camera pointing towards the object at a specific distance.
     * @param rootObject - The object to point at.
     * @param centerOffset - The distance offset from the object to point at.
     * @param targetOffset - The distance offset for the target from the center of object to point at.
     * @param options - Not used yet.
     */
    resetCamera({ rootObject, centerOffset, targetOffset, ...options }?: AnyOptions): void;
    fitToView(selected?: Object3D, distanceMultiplier?: number, duration?: number, ease?: Easing | EasingFunctionType): Promise<void>;
    /**
     * Create a new empty object in the scene or add an existing three.js object to the scene.
     * @param object
     */
    createObject3D(object?: Object3D): Promise<Object3DModel | undefined>;
    /**
     * Create a new physical material from a template or another material. It returns the same material if a material is passed created by the material manager.
     * @param material
     */
    createPhysicalMaterial(material?: Material | MeshPhysicalMaterialParameters): MeshStandardMaterial2 | undefined;
    /**
     * Create a new material from a template or another material. It returns the same material if a material is passed created by the material manager.
     * @param template - template name registered in MaterialManager
     * @param material - three.js material object or material params to create a new material
     */
    createMaterial<T extends IMaterial<any>>(template: 'standard' | 'basic' | 'diamond' | string, material?: Material | any): T | undefined;
    /**
     * Serialize all the plugins and their settings to save or create presets. Used in {@see toJSON}.
     * @param meta -  The meta object.
     * @param filter - List of PluginType for the to include.
     * @returns {any[]}
     */
    serializePlugins(meta?: any, filter?: string[]): any[];
    /**
     * Deserialize all the plugins and their settings from a preset. Used in {@see fromJSON}.
     * @param plugins - The output of {@see serializePlugins}.
     * @param meta - The meta object.
     * @returns {this}
     */
    deserializePlugins(plugins: any[], meta?: any): this;
    /**
     * Traverse all objects in scene model root.
     * @param callback
     */
    traverseSceneObjects<T extends ISceneObject = IModel<Object3D>>(callback: (o: Object3D & T) => void): void;
    /**
     * Serialize all the viewer and plugin settings and versions.
     * @param meta - The meta object.
     * @param pluginFilter - List of PluginType to include.
     * @returns {any} - Serializable JSON object.
     */
    toJSON(meta?: any, pluginFilter?: string[]): any;
    /**
     * Deserialize all the viewer and plugin settings.
     * @param data - The serialized JSON object retured from {@see toJSON}.
     * @param meta - The meta object
     * @returns {this}
     */
    fromJSON(data: any, meta?: any): this;
    get renderManager(): BaseRenderer;
    get assetManager(): AssetManagerPlugin | undefined;
    /**
     * Add an object/model/material/viewer-config/plugin-preset/... to the viewer scene from url or an {@link IAsset} object.
     * Same as {@link AssetManager.addAssetSingle}
     * @param obj
     * @param options
     */
    load<T = any>(obj: string | IAsset | null, options?: ImportAddOptions): Promise<T | undefined>;
    /**
     * Set the environment map of the scene from url or an {@link IAsset} object.
     * @param map
     * @param setBackground - Set the background image of the scene from the same map.
     * @param options - Options for importing the asset. See {@link ImportAssetOptions}
     */
    setEnvironmentMap(map: string | IAsset | null | ITexture | Texture | undefined, { setBackground, ...options }?: ImportAssetOptions & {
        setBackground?: boolean;
    }): Promise<(ITexture & Texture) | null>;
    /**
     * Set the background image of the scene from url or an {@link IAsset} object.
     * @param map
     * @param setEnvironment - Set the environment map of the scene from the same map.
     * @param options - Options for importing the asset. See {@link ImportAssetOptions}
     */
    setBackgroundMap(map: string | IAsset | null | ITexture | Texture | undefined, { setEnvironment, ...options }?: ImportAssetOptions & {
        setBackground?: boolean;
    }): Promise<(ITexture & Texture) | null>;
    private _setActiveCameraView;
    alert: (message?: string) => Promise<void>;
    confirm: (message?: string) => Promise<boolean>;
    prompt: (message?: string, _default?: string, cancel?: boolean) => Promise<string | null>;
}
/**
 * Type for {@see envMapBackground}
 * @deprecated will be removed
 */
export type EnvMapBackground = 'envMapBackground';
/**
 * Special value for background to use the environment map.
 * @deprecated will be removed, use 'environment' instead by passing into {@see RootScene.setBackground}
 * @type {string}
 */
export declare const envMapBackground: EnvMapBackground;
//# sourceMappingURL=ViewerApp.d.ts.map