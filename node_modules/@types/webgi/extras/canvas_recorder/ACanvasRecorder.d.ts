import { SimpleEventDispatcher } from 'ts-browser-helpers';
export type TRecorderStates = 'stopped' | 'recording' | 'paused' | 'error' | 'starting' | 'stopping';
export interface ICanvasRecorder<T extends string = any> extends SimpleEventDispatcher<T | TRecorderStates> {
    state: TRecorderStates;
    setOptions: (options: Partial<CanvasRecorderOptions>) => void;
    isRecording: () => boolean;
    requestFrame: () => boolean;
    dispose: () => void;
    options: CanvasRecorderOptions;
    start: () => void;
    pause: () => void;
    stop: (recordingCallback: (b: Blob) => void) => void;
}
export interface CanvasRecorderOptions {
    frameRate: number;
    mimeType: string;
    videoBitsPerSecond?: number;
    stepMode: boolean;
}
export declare abstract class ACanvasRecorder<T extends string = any> extends SimpleEventDispatcher<T | TRecorderStates> implements ICanvasRecorder<T> {
    options: CanvasRecorderOptions;
    protected _canvas: HTMLCanvasElement;
    private _state;
    protected _console: Console;
    protected _currentRecording: Blob[];
    get state(): TRecorderStates;
    setState(value: 'stopped' | 'recording' | 'paused' | 'error' | 'starting' | 'stopping', event?: any): void;
    protected _setOptions(value: Partial<CanvasRecorderOptions>): void;
    setOptions(options: Partial<CanvasRecorderOptions>): void;
    constructor(canvas: HTMLCanvasElement, options?: Partial<CanvasRecorderOptions>);
    isRecording(): boolean;
    protected _frameCount: number;
    requestFrame(): boolean;
    dispose(): void;
    abstract start(): void;
    abstract pause(): void;
    abstract stop(recordingCallback: (b: Blob) => void): void;
    protected _ondataavailable: (event: BlobEvent) => void;
}
//# sourceMappingURL=ACanvasRecorder.d.ts.map