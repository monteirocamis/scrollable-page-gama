/**
 * @license
 * ts-browser-helpers v0.7.0
 * Copyright 2022-2023 repalash <palash@shaders.app>
 * MIT License
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["ts-browser-helpers"] = {}));
})(this, (function (exports) { 'use strict';

    /**
     * A simple event dispatcher with typed event types, see {@link IEventDispatcher}.
     */
    class SimpleEventDispatcher {
        constructor() {
            this._eventListeners = {};
            this.dispatchEvent = this.dispatchEvent.bind(this);
            this.addEventListener = this.addEventListener.bind(this);
            this.removeEventListener = this.removeEventListener.bind(this);
            this.hasEventListener = this.hasEventListener.bind(this);
        }
        addEventListener(type, listener) {
            const listeners = this._eventListeners;
            if (listeners[type] === undefined)
                listeners[type] = [];
            if (!listeners[type].includes(listener))
                listeners[type].push(listener);
        }
        hasEventListener(type, listener) {
            const listeners = this._eventListeners;
            return listeners[type] !== undefined && listeners[type].includes(listener);
        }
        removeEventListener(type, listener) {
            const listeners = this._eventListeners;
            const listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                const index = listenerArray.indexOf(listener);
                if (index !== -1)
                    listenerArray.splice(index, 1);
            }
        }
        dispatchEvent(event) {
            const listeners = this._eventListeners;
            const listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                // Make a copy, in case listeners are removed while iterating.
                const array = listenerArray.slice(0);
                for (let i = 0, l = array.length; i < l; i++)
                    array[i].call(this, event);
            }
        }
    }

    /**
     * Returns a promise that resolves after the given duration. Basically a setTimeout that returns a promise.
     * @param duration - in ms
     *
     * @category Time
     */
    async function timeout(duration) {
        return new Promise(resolve => setTimeout(resolve, Math.max(0, duration)));
    }
    /**
     * Returns the current time in milliseconds. If performance.now() is available, it is used, otherwise Date.now() is used.
     *
     * @category Time
     */
    function now() {
        return (typeof performance === 'undefined' ? Date : performance).now(); // see threejs  #10732
    }

    /**
     * A helper class to handle pointer events and dispatch drag events: `drag`, `dragStart` and `dragEnd` with NDC coordinates and time.
     *
     * To use, create an object of the class, set `element` with the HTML element(like canvas) and add event listeners to drag events.
     *
     * @example
     * ```ts
     * const pointerDragHelper = new PointerDragHelper()
     * pointerDragHelper.element = canvas
     * pointerDragHelper.addEventListener('dragStart', (e) => {
     *    console.log('dragStart', e.pointer)
     *    // {x: -0.5, y: 0.5, time: 123456789}
     *    // x and y are NDC coordinates, time is the time when the event is fired.
     *    // x and y are in the range of [-1, 1].
     *    // x is left to right, y is bottom to top.
     *    // time is in milliseconds.
     * })
     * pointerDragHelper.addEventListener('drag', (e) => {
     *   console.log('drag', e.pointer)
     *   // {x: -0.5, y: 0.5, time: 123456789}
     * })
     * pointerDragHelper.addEventListener('dragEnd', (e) => {
     *  console.log('dragEnd', e.pointer)
     *  // {x: -0.5, y: 0.5, time: 123456789}
     * })
     * ```
     */
    class PointerDragHelper extends SimpleEventDispatcher {
        constructor() {
            super(...arguments);
            this._onPointerDown = (e) => {
                if (e.button !== 0)
                    return;
                if (!this._element)
                    return;
                this._pointerUp = undefined;
                const x = e.clientX / this._element.clientWidth * 2 - 1;
                const y = -(e.clientY / this._element.clientHeight) * 2 + 1;
                const time = now();
                this._pointerDown = { x, y, time };
                this._pointer = this._pointerDown;
                this.dispatchEvent({ type: 'dragStart', pointer: this._pointerDown });
            };
            this._onPointerMove = (e) => {
                if (!this._pointerDown || !this._pointer)
                    return;
                if (!this._element)
                    return;
                const x = e.clientX / this._element.clientWidth * 2 - 1;
                const y = -(e.clientY / this._element.clientHeight) * 2 + 1;
                const time = now();
                this.dispatchEvent({
                    type: 'drag', pointer: this._pointer,
                    drag: { x: x - this._pointerDown.x, y: y - this._pointerDown.y, time: time - this._pointerDown.time },
                    delta: { x: x - this._pointer.x, y: y - this._pointer.y, time: time - this._pointer.time },
                });
                this._pointer = { x: x, y: y, time: now() };
                if (e.buttons % 2 === 0)
                    this._onPointerUp(e);
            };
            this._onPointerUp = (e) => {
                if (e.button !== 0)
                    return;
                if (!this._pointerDown)
                    return;
                if (!this._element)
                    return;
                const x = e.clientX / this._element.clientWidth * 2 - 1;
                const y = -(e.clientY / this._element.clientHeight) * 2 + 1;
                const time = now();
                this._pointerUp = { x: x, y: y, time };
                this.dispatchEvent({
                    type: 'dragEnd', pointer: this._pointerUp,
                    drag: {
                        x: this._pointerUp.x - this._pointerDown.x,
                        y: this._pointerUp.y - this._pointerDown.y,
                        time: this._pointerUp.time - this._pointerDown.time,
                    },
                });
                this._pointerDown = undefined;
                this._pointer = undefined;
            };
        }
        get element() {
            return this._element;
        }
        set element(value) {
            if (this._element === value)
                return;
            if (this._element)
                this._removeElement();
            this._element = value;
            if (this._element)
                this._addElement();
        }
        _removeElement() {
            var _a, _b, _c, _d, _e;
            (_a = this._element) === null || _a === void 0 ? void 0 : _a.removeEventListener('pointerdown', this._onPointerDown);
            (_b = this._element) === null || _b === void 0 ? void 0 : _b.removeEventListener('pointermove', this._onPointerMove);
            (_c = this._element) === null || _c === void 0 ? void 0 : _c.removeEventListener('pointerup', this._onPointerUp);
            (_d = this._element) === null || _d === void 0 ? void 0 : _d.removeEventListener('pointercancel', this._onPointerUp);
            (_e = this._element) === null || _e === void 0 ? void 0 : _e.removeEventListener('pointerout', this._onPointerUp);
        }
        _addElement() {
            var _a, _b, _c, _d, _e;
            (_a = this._element) === null || _a === void 0 ? void 0 : _a.addEventListener('pointerdown', this._onPointerDown);
            (_b = this._element) === null || _b === void 0 ? void 0 : _b.addEventListener('pointermove', this._onPointerMove);
            (_c = this._element) === null || _c === void 0 ? void 0 : _c.addEventListener('pointerup', this._onPointerUp);
            (_d = this._element) === null || _d === void 0 ? void 0 : _d.addEventListener('pointercancel', this._onPointerUp);
            (_e = this._element) === null || _e === void 0 ? void 0 : _e.addEventListener('pointerout', this._onPointerUp);
        }
        dispose() {
            this.element = undefined;
        }
    }

    /* @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the 'License');
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an 'AS IS' BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * The Damper class is a generic second-order critically damped system that does
     * one linear step of the desired length of time. The only parameter is
     * DECAY_MILLISECONDS. This common parameter makes all states converge at the
     * same rate regardless of scale. xNormalization is a number to provide the
     * rough scale of x, such that NIL_SPEED clamping also happens at roughly the
     * same convergence for all states.
     *
     * Taken from Google model-viewer.
     *
     * https://github.com/google/model-viewer/blob/ec527bc1d0e1bcb4421fa192a7e62bbc5764db91/packages/model-viewer/src/three-components/Damper.ts#L1
     */
    class Damper {
        constructor(decayMilliseconds = Damper.DECAY_MILLISECONDS) {
            this.velocity = 0;
            this.naturalFrequency = 0;
            this.setDecayTime(decayMilliseconds);
        }
        setDecayTime(decayMilliseconds) {
            this.naturalFrequency =
                1 / Math.max(Damper.MIN_DECAY_MILLISECONDS, decayMilliseconds);
        }
        update(v, vGoal, timeStepMilliseconds, xNormalization) {
            const nilSpeed = 0.0002 * this.naturalFrequency;
            if (v == null || xNormalization === 0) {
                return vGoal;
            }
            if (v === vGoal && this.velocity === 0) {
                return vGoal;
            }
            if (timeStepMilliseconds < 0) {
                return v;
            }
            // Exact solution to a critically damped second-order system, where:
            // acceleration = this.naturalFrequency * this.naturalFrequency * (vGoal
            // - v) - 2 * this.naturalFrequency * this.velocity;
            const deltaV = (v - vGoal);
            const intermediateVelocity = this.velocity + this.naturalFrequency * deltaV;
            const intermediateX = deltaV + timeStepMilliseconds * intermediateVelocity;
            const decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds);
            const newVelocity = (intermediateVelocity - this.naturalFrequency * intermediateX) * decay;
            const acceleration = -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);
            if (Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) &&
                acceleration * deltaV >= 0) {
                // This ensures the controls settle and stop calling this function instead
                // of asymptotically approaching their goal.
                this.velocity = 0;
                return vGoal;
            }
            else {
                this.velocity = newVelocity;
                return vGoal + intermediateX * decay;
            }
        }
    }
    Damper.SETTLING_TIME = 10000; // plenty long enough
    Damper.MIN_DECAY_MILLISECONDS = 0.001;
    Damper.DECAY_MILLISECONDS = 50;

    /**
     * Creates a HTML canvas element.
     * @category DOM
     */
    function createCanvasElement() {
        const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.style.display = 'block';
        return canvas;
    }
    /**
     * Creates a HTML div element.
     * @param innerHTML - HTML string to add to the div
     * @param id - id of the div
     * @param classList - list of classes to add to the div
     * @param addToBody - add the div to the body
     * @param elementTag - tag of the element to create (default: div)
     *
     * @category DOM
     */
    function createDiv({ innerHTML = '', id, classList, addToBody = true, elementTag = 'div' }) {
        const elem = document.createElement(elementTag);
        if (id)
            elem.id = id;
        elem.innerHTML = innerHTML;
        if (classList)
            elem.classList.add(...classList);
        if (addToBody)
            document.body.appendChild(elem);
        return elem;
    }
    /**
     * Creates a HTML image element from a url.
     * @param url - url of the image
     *
     * @category DOM
     */
    async function createImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.crossOrigin = 'anonymous';
            img.decoding = 'sync';
            img.src = url;
        });
    }
    /**
     * Creates a HTML style element with the given styles.
     * @param styles - CSS string
     * @param root - root element to add the style to (default: head)
     *
     * @category DOM
     */
    function createStyles(styles, root = document.head) {
        const styleSheet = document.createElement('style');
        styleSheet.type = 'text/css';
        styleSheet.innerText = styles;
        root === null || root === void 0 ? void 0 : root.appendChild(styleSheet);
        return styleSheet;
    }
    /**
     * Creates a HTML script element from a url.
     * @param url - url of the script
     * @param root - root element to add the script to (default: head)
     *
     * @category DOM
     */
    async function createScriptFromURL(url, root = document.head) {
        return new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.setAttribute('src', url);
            s.addEventListener('load', () => resolve(s));
            s.addEventListener('error', reject);
            root.appendChild(s);
        });
    }

    /**
     * Convert an ArrayBuffer to Base64 string
     * @param buffer - ArrayBuffer to convert
     * @category ArrayBuffer
     */
    function arrayBufferToBase64(buffer) {
        if (!window) {
            console.warn('window is required');
            return '';
        }
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }
    /**
     * Convert a Base64 string to ArrayBuffer
     * @param base64 - Base64 string to convert
     * @category ArrayBuffer
     */
    function base64ToArrayBuffer(base64) {
        if (!window) {
            console.warn('window is required');
            return new Uint8Array(0);
        }
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
    // if (!ArrayBuffer.prototype.slice)
    //     ArrayBuffer.prototype.slice = function(start, end) {
    //         const that = new Uint8Array(this)
    //         if (end == undefined) end = that.length
    //         const result = new ArrayBuffer(end - start)
    //         const resultArray = new Uint8Array(result)
    //         for (let i = 0; i < resultArray.length; i++)
    //             resultArray[i] = that[i + start]
    //         return result
    //     }
    /**
     * Mapping of typed array constructors by name
     * @category ArrayBuffer
     */
    const TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
    };
    /**
     * Create a typed array from an ArrayBuffer by name
     * @param type - Name of the typed array constructor
     * @param buffer - ArrayBuffer to use
     * @category ArrayBuffer
     */
    function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
    }

    /**
     * Convert a string to title case
     * @param str - The string to convert
     *
     * @category Text
     */
    function toTitleCase(str) {
        return str.replace(/\w\S*/g, function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    }
    /**
     * Parse a file extension from a path
     * @param path - The path to parse
     * @returns file extension without the dot (e.g. 'png')
     *
     * @category Text
     */
    function parseFileExtension(path) {
        var _a;
        if (!path || path === '' || path.match(/__MACOSX\/.*\._/))
            return ''; // todo: proper hidden files checks
        path = path.replace(/\?.*$/, ''); // remove query string
        const basename = (_a = path.split(/[\\/]/).pop()) !== null && _a !== void 0 ? _a : '', pos = basename.lastIndexOf('.');
        if (basename === '' || pos < 1)
            return '';
        return basename.slice(pos + 1);
    }
    /**
     * Get the filename from a path, similar to PHP's basename()
     * @param url
     *
     * @category Text
     */
    function getFilenameFromPath(url) {
        return url.substring(url.lastIndexOf('/') + 1);
    }
    /**
     * Escape a string for use in a regular expression
     * @param str
     *
     * @category Text
     */
    function escapeRegExp(str) {
        return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1');
    }
    /**
     * Replace all occurrences of a string in another string
     * @param str - The string to search
     * @param find - The string to replace
     * @param replace - The replacement string
     *
     * @category Text
     */
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
    }
    /**
     * Find the longest common prefix in an array of strings
     * https://stackoverflow.com/questions/68702774/longest-common-prefix-in-javascript
     * @param words
     */
    function longestCommonPrefix(words) {
        words.sort(); // shortest string will be first and the longest last
        return (words[0].split('') // converts shortest word to an array of chars
            .map((char, idx) => words[words.length - 1][idx] === char ? char : '\0') // replaces non-matching chars with NULL char
            .join('') // converts back to a string
            .split('\0') // splits the string by NULL characters
            .at(0) // returns the first part
            || '');
    }

    /**
     * A template literal tag that does nothing. Useful for syntax highlighting of GLSL code.
     *
     * @example
     * ```js
     * const vertexShader = glsl`
     *    void main() {}
     * `
     * ```
     * @category Template Literals
     */
    const glsl = (strings, ...rest) => String.raw({ raw: strings }, ...rest);
    /**
     * A template literal tag that does nothing. Useful for syntax highlighting of CSS code.
     *
     * @example
     * ```js
     * const vertexShader = css`
     *    .my-class {
     *        color: red;
     *    }
     * `
     * ```
     * @category Template Literals
     */
    const css = (strings, ...rest) => String.raw({ raw: strings }, ...rest);
    /**
     * A template literal tag that does nothing. Useful for syntax highlighting of HTML code.
     *
     * @example
     * ```js
     * const vertexShader = html`
     *    <div class="my-class">
     *        <p>Some text</p>
     *    </div>
     * `
     * ```
     * @category Template Literals
     */
    const html = (strings, ...rest) => String.raw({ raw: strings }, ...rest);
    /**
     * Converts an SVG string to data url. This is useful for creating images from SVGs, or using SVGs in CSS.
     * To use put in template string: `url(${svgUrl\`<svg>...</svg>\`})`
     * @param strings - template strings
     * @param rest - template values
     *
     * @example
     * ```ts
     * const url = svgUrl\`
     *  <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> ... </svg>
     * \`
     * console.log(url) // data:image/svg+xml;charset=UTF-8,...
     * ```
     *
     * @category Template Literals
     */
    const svgUrl = (strings, ...rest) => {
        let encoded = String.raw({ raw: strings }, ...rest);
        encoded = replaceAll(encoded, '%', '%25');
        encoded = replaceAll(encoded, '> <', '><'); // normalise spaces elements
        encoded = replaceAll(encoded, '; }', ';}'); // normalise spaces css
        encoded = replaceAll(encoded, '<', '%3c');
        encoded = replaceAll(encoded, '>', '%3e');
        encoded = replaceAll(encoded, '"', '\'');
        encoded = replaceAll(encoded, '#', '%23'); // needed for ie and firefox
        encoded = replaceAll(encoded, '{', '%7b');
        encoded = replaceAll(encoded, '}', '%7d');
        encoded = replaceAll(encoded, '|', '%7c');
        encoded = replaceAll(encoded, '^', '%5e');
        encoded = replaceAll(encoded, '`', '%60');
        encoded = replaceAll(encoded, '@', '%40');
        encoded = replaceAll(encoded, '&', '&amp;');
        encoded = replaceAll(encoded, '\n', '%0A');
        return 'data:image/svg+xml;charset=UTF-8,' + encoded;
    };

    /**
     * Styles the default scrollbar to be more pretty and less intrusive (especially on dark backgrounds), (similar to MacOS)
     */
    function prettyScrollbar(root = document.head) {
        return createStyles(css `
      ::-webkit-scrollbar
      {
        width: 8px;  /* for vertical scrollbars */
        height: 8px; /* for horizontal scrollbars */
      }
      ::-webkit-scrollbar-track
      {
        background: rgba(64, 64, 64, 0.4);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-thumb
      {
        background: rgba(128, 128, 128, 0.2);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-corner {background: rgba(0,0,0,0.5);}
    `, root);
    }

    /**
     * Download a blob as a file in the browser.
     * @param b - blob to download
     * @param name - name of the file
     * @category Browser
     */
    function downloadBlob(b, name) {
        const url = window.URL.createObjectURL(b);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 1000);
    }
    /**
     * Convert a blob to a data url.
     * @param blob - blob to convert
     * @category Browser
     */
    async function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = _e => resolve(reader.result);
            reader.onerror = _e => reject(reader.error);
            reader.onabort = _e => reject(new Error('Read aborted'));
            reader.readAsDataURL(blob);
        });
    }
    /**
     * Download a file in the browser.
     * @param b - file to download
     * @param name - name of the file (optional)
     * @category Browser
     */
    function downloadFile(b, name) {
        return downloadBlob(b, name !== null && name !== void 0 ? name : b.name);
    }
    // todo: add/test options for multiple files and directory upload
    /**
     * Prompt the user to select a file or directory in the browser.
     * @param multiple - allow multiple files
     * @param directory - allow directory
     * @param accept - file types to accept (default: all), e.g. 'image/*'
     * @category Browser
     */
    async function uploadFile(multiple = false, directory = false, accept) {
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = multiple;
        input.accept = accept || '*';
        input.webkitdirectory = directory;
        input.style.display = 'none';
        document.body.appendChild(input);
        input.click();
        const files = await new Promise((resolve) => {
            input.onchange = _e => {
                resolve(Array.from(input.files || []));
            };
        });
        document.body.removeChild(input);
        return files;
    }
    /**
     * Check if the browser is running on a mobile or tablet device.
     */
    function mobileAndTabletCheck() {
        let check = false;
        // @ts-expect-error copied
        (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true; })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
    }

    // from three.js
    /**
     * Converts a single color channel from the sRGB color space to linear.
     * @param c - The color channel to be converted.
     * @category Color
     */
    function SRGBToLinear(c) {
        return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    /**
     * Converts a single color channel from the linear color space to sRGB.
     * @param c - The color channel to be converted.
     * @category Color
     */
    function LinearToSRGB(c) {
        return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
    }
    /**
     * Creates an image data url from a color string.
     * @param color - color string (css compatible color)
     * @param width - width of the image (default: 1)
     * @param height - height of the image (default: 1)
     * @return {string} - data url
     */
    function colorToDataUrl(color, width = 1, height = 1) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#' + color;
        ctx.fillRect(0, 0, width, height);
        const url = canvas.toDataURL();
        canvas.remove();
        return url;
    }

    /**
     * Get property descriptor from object or its prototype chain
     * @param obj
     * @param prop
     *
     * @category JS Object
     */
    function getPropertyDescriptor(obj, prop) {
        let desc;
        do {
            desc = Object.getOwnPropertyDescriptor(obj, prop);
        } while (!desc && (obj = Object.getPrototypeOf(obj)));
        return desc;
    }
    /**
     * Check if property is writable in object or its prototype chain
     * @param object - object to check
     * @param prop - property to check
     * @param allowWritable - allow writable properties without setter
     * @param allowAny - allow any property (even if it doesn't exist)
     *
     * @category JS Object
     */
    function isPropertyWritable(object, prop, allowWritable = true, allowAny = false) {
        const desc = getPropertyDescriptor(object, prop);
        return !!(desc === null || desc === void 0 ? void 0 : desc.set)
            || allowWritable && (desc === null || desc === void 0 ? void 0 : desc.writable) !== false && (desc === null || desc === void 0 ? void 0 : desc.get) === undefined
            || allowAny && !desc;
    }
    /**
     * Set value only if setter exists
     * @param object - object to set
     * @param prop - property to set
     * @param value - value to set
     * @param allowWritable - allow writable properties without setter
     * @param allowAny - allow any property (even if it doesn't exist)
     *
     * @category JS Object
     */
    function safeSetProperty(object, prop, value, allowWritable = true, allowAny = false) {
        // check type?
        if (object && isPropertyWritable(object, prop, allowWritable, allowAny)) {
            object[prop] = value;
            return true;
        }
        return false;
    }
    /**
     * Get value, but if it is a function, call it with args
     * @param s - value or function
     * @param args - arguments to pass to function
     *
     * @category JS Object
     */
    function getOrCall(s, ...args) {
        if (typeof s === 'function')
            s = s(...args);
        return s;
    }
    /**
     * Copy properties from source to dest. Similar to Object.assign, but only copies properties that exist in source, dest and propList.
     * @param source - source object
     * @param dest - destination object
     * @param propList - list of properties to copy
     *
     * @category JS Object
     */
    function copyProps(source, dest, propList) {
        for (const str of propList) {
            const s = source[str];
            if (s !== undefined)
                safeSetProperty(dest, str, s, true);
            // if (s !== undefined) dest[str] = s
        }
        return dest;
    }

    /**
     * Returns true if the array includes all the elements of the sub array
     * @param arr
     * @param subArr
     */
    function includesAll(arr, subArr) {
        for (const sub of subArr) {
            if (!arr.includes(sub))
                return false;
        }
        return true;
    }
    /**
     * like Array.prototype.findIndex but from the end
     * @param arr
     * @param predicate
     */
    function findLastIndex(arr, predicate) {
        for (let i = arr.length - 1; i >= 0; i--) {
            if (predicate(arr[i]))
                return i;
        }
        return -1;
    }

    const objSerializer = {
        priority: Infinity,
        serialize: (obj, meta) => Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, Serialization.Serialize(v, meta, false)])),
        deserialize: (data, obj, meta) => Object.assign(obj || {}, Object.fromEntries(Object.entries(data).map(([k, v]) => [k, Serialization.Deserialize(v, obj === null || obj === void 0 ? void 0 : obj[k], meta, false)]))),
        isType: (obj) => (obj.constructor || Object) === Object,
    };
    /**
     * Serialization class with static methods for serializing and deserializing objects.
     * Properties and classes can be marked serializable by adding {@link serialize} and {@link serializable} decorators.
     * @category Serialization
     */
    class Serialization {
        static GetSerializer(obj) {
            return Serialization.Serializers.find(s => s.isType(obj));
        }
        static RegisterSerializer(...serializers) {
            var _a;
            for (const serializer of serializers) {
                const priority = (_a = serializer.priority) !== null && _a !== void 0 ? _a : 1e10;
                const i = findLastIndex(Serialization.Serializers, s => s.priority !== undefined && s.priority < priority);
                if (i >= 0)
                    Serialization.Serializers.splice(i + 1, 0, serializer);
                else
                    Serialization.Serializers.push(serializer);
            }
        }
        static UnregisterSerializer(...serializers) {
            for (const serializer of serializers) {
                const i = Serialization.Serializers.indexOf(serializer);
                if (i >= 0)
                    Serialization.Serializers.splice(i, 1);
            }
        }
        /**
         * Serialize an object
         * @param obj - object to serialize
         * @param meta - Optional object to store common meta-data/resources across the serialization process of multiple objects
         @param isThis - true if called from inside the serialization function, like custom {@link IJSONSerializable.toJSON}.
         */
        static Serialize(obj, meta, isThis = false) {
            var _a, _b;
            if (typeof obj === 'function')
                return undefined;
            if (!isThis) {
                const serializer = Serialization.GetSerializer(obj);
                if (serializer)
                    return serializer.serialize(obj, meta);
                // Handle classes with explicit serialization with toJSON and fromJSON functions
                // toJSON functions can call Serialize(with isThis=true) to serialize the properties with @serialize decorator
                if (typeof obj.toJSON === 'function') {
                    const res = obj.toJSON(meta);
                    if (obj.serializableClassId && res)
                        res.serializableClassId = obj.serializableClassId;
                    return res;
                }
            }
            // Handle classes with @serializable decorator and serialize all properties with @serialize decorator
            let type = (_a = obj.constructor) !== null && _a !== void 0 ? _a : Object;
            const result = {};
            // Loop through all parent classes and serialize properties with @serialize decorator
            while (type && type !== Object) {
                const Type = (_b = Serialization.TypeMap.get(type)) !== null && _b !== void 0 ? _b : [];
                for (const [key, propKey] of Type) {
                    result[key] = Serialization.Serialize(obj[propKey], meta, false);
                }
                type = Object.getPrototypeOf(type);
            }
            if (obj.serializableClassId)
                result.serializableClassId = obj.serializableClassId;
            return result;
        }
        /**
         * Deserialize an object
         * @param data - data to deserialize
         * @param obj - current object that's set. If of the same class/type the data is deserialized into that instead of creating new objects.
         * @param meta - Optional object to retrieve common meta-data/resources across the deserialization process of multiple objects. Objects in meta must be class instances, not js objects. (like Material, Texture, Object3D etc)
         * @param isThis - true if called from inside the deserialization function, like custom {@link IJSONSerializable.fromJSON}
         */
        static Deserialize(data, obj, meta, isThis = false) {
            var _a, _b;
            if (data === undefined)
                return obj; // undefined is not deserialized
            if (obj === data)
                return obj; // same object
            // let isResource = false
            // If data is an embedded resource in meta
            if (data && typeof data === 'object' && (data.constructor || Object) === Object && data.resource && typeof data.resource === 'string' && data.uuid) {
                const res = meta === null || meta === void 0 ? void 0 : meta[data.resource];
                if (res) {
                    // isResource = true
                    data = res[data.uuid];
                    if (typeof data === 'object') {
                        data.__useCount = data.__useCount ? data.__useCount + 1 : 1; // used for materials for now, see AssetManagerPlugin.importViewerConfig
                    }
                    if (!data)
                        console.warn(`Resource ${data.resource} with uuid ${data.uuid} not found`);
                    if (obj === data)
                        return obj; // same object
                    if (data && typeof data === 'object') {
                        const isDeserializedClass = (data.constructor || Object) !== Object; // data is already deserialized
                        if (isDeserializedClass) {
                            if (!obj) {
                                return data;
                            }
                            else {
                                // todo: if data is deserialized already and !== obj.
                                // obj is not null, could be a Texture, Material, Object etc
                                // should we ignore the current object and assign one from meta or copy data from meta to current object
                                // for textures, it should be replaced. should we copy if uuid is same?
                                // for materials, if uuid is same and type is same it should be copied otherwise replaced
                                // for vector3d, copy data
                                // todo: need to implement.
                                console.warn("replacing object", obj, 'with deserialized object from meta', data);
                                return data;
                            }
                        }
                        else { // data is not deserialized, or is a normal object
                            // this is not supported. meta should only have class instances, not js objects
                            console.error('Deserialize; meta should only have class instances, not js objects', data, obj, meta);
                        }
                    }
                }
                else {
                    console.warn(`Resource ${data.resource} not found`);
                    return obj;
                }
            }
            if (data && typeof data === 'object' && (data.constructor || Object) !== Object && !Array.isArray(data)) {
                console.warn('Data might already be deserialized. It will be cloned, or copied to source', data, "source", obj, data.constructor, data.constructor !== Object);
            }
            // Create new object if not provided
            if (data && typeof data === 'object') {
                // if data is deserialized already and obj is null. then should we clone the data or assign it directly?
                // if it's a resource from meta then assign it directly(done above), otherwise clone (done just below).
                if (data.serializableClassId && (!obj || obj.serializableClassId !== data.serializableClassId)) { // if the data is already deserialized, it will be cloned
                    const constructor = Serialization.SerializableClasses.get(data.serializableClassId);
                    if (constructor) {
                        if (constructor.DataInConstructor) // not used anywhere right now. todo: remove? because we are anyway assigning the data to the object after the constructor using @serialize and support fromJSON
                            obj = new constructor(data);
                        else
                            obj = new constructor();
                    }
                }
                else if ((data.constructor || Object) === Object && !obj) {
                    obj = {};
                }
                else if (Array.isArray(data) && !obj) {
                    obj = [];
                }
            }
            if (typeof obj === 'function') {
                console.error('cannot deserialize over function', obj, data);
                return obj; // throw error maybe?}
            }
            if (!isThis) {
                const serializer = Serialization.GetSerializer(data);
                if (serializer && serializer !== objSerializer)
                    return serializer.deserialize(data, obj, meta);
            }
            if (!data || obj === undefined || obj === null || typeof obj !== 'object') {
                return data;
            }
            // Handle classes with explicit serialization with toJSON and fromJSON functions
            // fromJSON functions can call Deserialize(with isThis=true) to deserialize the properties with @serialize decorator
            if (!isThis && typeof (obj === null || obj === void 0 ? void 0 : obj.fromJSON) === 'function') {
                obj.fromJSON(data, meta);
                return obj; // cannot be sure what the return value is
            }
            let type = (_a = obj.constructor) !== null && _a !== void 0 ? _a : Object;
            if (type === Object)
                return objSerializer.deserialize(data, obj, meta);
            // Loop through all parent classes and deserialize properties with @serialize decorator
            while (type && type !== Object) {
                const Type = (_b = Serialization.TypeMap.get(type)) !== null && _b !== void 0 ? _b : [];
                for (const [key, propKey] of Type) {
                    const current = obj[propKey];
                    const newVal = Serialization.Deserialize(data[key], current, meta, false);
                    if (newVal !== current)
                        safeSetProperty(obj, propKey, newVal, true);
                }
                type = Object.getPrototypeOf(type);
            }
            return obj;
        }
    }
    Serialization.TypeMap = new Map();
    Serialization.SerializableClasses = new Map();
    /**
     * Serializers for primitive, array and struct/custom object types
     */
    Serialization.Serializers = [
        {
            priority: 0,
            isType: (obj) => Array.isArray(obj),
            serialize: (obj, meta) => obj.map((v) => Serialization.Serialize(v, meta, false)),
            deserialize: (data, obj, meta) => {
                const l = data.length;
                if (!Array.isArray(obj))
                    obj = [];
                for (let i = 0; i < l; i++) {
                    const d = data[i];
                    const de = obj.length > i ? Serialization.Deserialize(d, obj[i], meta, false) : Serialization.Deserialize(d, undefined, meta, false);
                    if (obj.length <= i)
                        obj.push(de);
                    else
                        obj[i] = de;
                }
                return obj;
            },
        },
        {
            priority: 0,
            isType: (obj) => !obj || typeof obj !== 'object',
            serialize: (obj) => {
                if (obj && typeof obj === 'number') {
                    if (obj === Infinity)
                        return 'Infinity';
                    if (obj === -Infinity)
                        return '-Infinity';
                    if (isNaN(obj))
                        return 'NaN';
                }
                return obj;
            },
            deserialize: (data, obj) => {
                if (typeof obj === 'number') {
                    if (data === 'Infinity')
                        return Infinity;
                    if (data === '-Infinity')
                        return -Infinity;
                    if (data === 'NaN')
                        return NaN;
                    if (typeof data === 'number' || !data)
                        return data;
                }
                return data;
            },
        },
        objSerializer,
    ];

    /**
     * Decorator that redefines a property with getter and setter, and calls a function when the property is changed.
     * Parameters passed to the function are the property key and the new value.
     * @note - Does not work with "target": "esnext" in tsconfig.json
     * @note - Requires "experimentalDecorators": true in tsconfig.json
     * @todo add example.
     * @param fnKey - use: `<MyClass>.prototype.<myFunction>` or define an arrow function: `(key, value, oldValue) => {}`.
     * @param paramType -
     * if param, the function is called with 3 parameters: `key, value, oldValue`, default for {@link onChange}
     * if object, the function is called with an object parameter: `{key, value, oldValue}`, default for {@link onChange3}
     * if void then no params are passed. {@link onChange2}
     * Default: false.
     *
     * @category Decorators
     */
    function onChange(fnKey
    //| ((obj:{key: string, value: any, oldValue: any})=>void)
    , paramType = 'param') {
        if (!fnKey)
            throw new Error('onChange: fnKey is undefined, make sure the function exists or provide a string');
        return (targetPrototype, propertyKey) => {
            Object.defineProperty(targetPrototype, propertyKey, {
                get() {
                    return this[`_oc_${propertyKey}`];
                },
                set(newVal) {
                    var _a;
                    const oldVal = this[`_oc_${propertyKey}`];
                    if (oldVal === newVal)
                        return;
                    this[`_oc_${propertyKey}`] = newVal;
                    const params = paramType === 'param' ? [propertyKey, newVal, oldVal] : paramType === 'object' ? [{ key: propertyKey, value: newVal, oldValue: oldVal }] : '';
                    if (typeof fnKey === 'string')
                        (_a = this[fnKey]) === null || _a === void 0 ? void 0 : _a.call(this, ...params);
                    else if (typeof fnKey === 'function') {
                        let called = false; // to get functions in the prototype chain
                        if (fnKey.name) {
                            let p = this;
                            while (p) {
                                if (p[fnKey.name] === fnKey) {
                                    fnKey.call(this, ...params);
                                    called = true;
                                    break;
                                }
                                p = Object.getPrototypeOf(p);
                            }
                        }
                        if (!called) {
                            if (fnKey.name && this[fnKey.name].name === `bound ${fnKey.name}`)
                                this[fnKey.name](...params);
                            else
                                fnKey(...params);
                        }
                    }
                },
            });
        };
    }
    /**
     * Similar to {@link onChange}, but accepts any function and paramType defaults to 'void'. The function is called with no parameters. if 'void'
     * @param fnKey
     * @param paramType
     */
    function onChange2(fnKey, paramType = 'void') {
        if (!fnKey)
            throw new Error('onChange: fnKey is undefined, make sure the function exists or provide a string');
        return onChange(fnKey, paramType);
    }
    /**
     * Similar to {@link onChange}, but accepts any function and paramType defaults to 'object'. The function is called with an object parameter: `{key, value, oldValue}`.
     * @param fnKey
     * @param paramType
     */
    function onChange3(fnKey, paramType = 'object') {
        if (!fnKey)
            throw new Error('onChange: fnKey is undefined, make sure the function exists or provide a string');
        return onChange(fnKey, paramType);
    }
    /**
     * Decorator to mark a class property as serializable using the {@link Serialization} class.
     * @note - Requires "experimentalDecorators": true in tsconfig.json
     * @param key - The key to use when serializing the property. If not provided, the property name is used (for this make sure the property name is not mangled during minification).
     * @category Decorators
     */
    function serialize(key) {
        return (targetPrototype, propertyKey) => {
            const type = targetPrototype.constructor;
            if (type === Object)
                throw new Error('All properties in an object are serialized by default');
            if (!Serialization.TypeMap.has(type))
                Serialization.TypeMap.set(type, []);
            Serialization.TypeMap.get(type).push([key || propertyKey, propertyKey]);
        };
    }
    /**
     * Decorator to mark a class as serializable using the {@link Serialization} class.
     * @note - Requires "experimentalDecorators": true in tsconfig.json
     * @param id - The id to use when serializing the class. This is used to identify the class when deserializing. Class names can be mangled during minification, so it is required to provide an id.
     */
    function serializable(id) {
        return (constructor) => {
            constructor = class extends constructor {
                constructor() {
                    super(...arguments);
                    this.serializableClassId = id;
                    // static DataInConstructor = false // if constructor is equivalent to fromJSON, see LUTCubeTextureWrapper.
                }
            };
            Serialization.SerializableClasses.set(id, constructor);
            return constructor;
        };
    }

    /**
     * Encrypts plaintext using AES-GCM with supplied password, for decryption with aesGcmDecrypt().
     *                                                                      (c) Chris Veness MIT Licence
     * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
     * Modified to work with Uint8Array and string content.
     *
     * @param content - Plaintext or Uint8 Buffer to be encrypted.
     * @param password - Plaintext or Uint8 Buffer Password to use to encrypt content.
     * @param prefix - Optional prefix to prepend to the ciphertext.
     * @returns Encrypted ciphertext. If content is a string, the ciphertext is a string. If content is a Uint8Array, the ciphertext is a new Uint8Array.
     *
     *
     * @example
     *   const ciphertext = await aesGcmEncrypt('my secret text', 'pw');
     *   aesGcmEncrypt('my secret text', 'pw').then(function(ciphertext) { console.log(ciphertext); });
     *
     * @category Encryption
     */
    async function aesGcmEncrypt(content, password, prefix) {
        const pwUtf8 = typeof password === 'string' ? new TextEncoder().encode(password) : password; // encode password as UTF-8
        const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8); // hash the password
        const iv = crypto.getRandomValues(new Uint8Array(12)); // get 96-bit random iv
        const ivStr = Array.from(iv).map(b => String.fromCharCode(b)).join(''); // iv as utf-8 string
        const alg = { name: 'AES-GCM', iv: iv }; // specify algorithm to use
        const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['encrypt']); // generate key from pw
        const ptUint8 = typeof content === 'string' ? new TextEncoder().encode(content) : content; // encode plaintext as UTF-8
        const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8); // encrypt plaintext using key
        const ctUint = new Uint8Array(ctBuffer);
        const ctArray = Array.from(ctUint); // ciphertext as byte array
        const ctStr = ctArray.map(byte => String.fromCharCode(byte)).join(''); // ciphertext as string
        const prefixStr = prefix ? typeof prefix === 'string' ? prefix : new TextDecoder().decode(prefix) : '';
        const prefixArray = prefix ? typeof prefix === 'string' ? new TextEncoder().encode(prefix) : Array.from(prefix) : [];
        return typeof content === 'string' ? (prefixStr + ivStr + ctStr) : new Uint8Array([...prefixArray, ...iv, ...ctArray]);
    }
    /**
     * Decrypts ciphertext encrypted with aesGcmEncrypt() using supplied password.
     *                                                                      (c) Chris Veness MIT Licence
     *
     * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
     * Modified to work with Uint8Array and string content.
     *
     * @param ciphertext - Ciphertext to be decrypted.
     * @param password - Password to use to decrypt ciphertext.
     * @returns Decrypted content. If ciphertext is a string, the plaintext is a string. If ciphertext is a Uint8Array, the plaintext is a new Uint8Array.
     *
     * @example
     *   const plaintext = await aesGcmDecrypt(ciphertext, 'pw');
     *   aesGcmDecrypt(ciphertext, 'pw').then(function(plaintext) { console.log(plaintext); });
     *
     * @category Encryption
     */
    async function aesGcmDecrypt(ciphertext, password) {
        const pwUtf8 = typeof password === 'string' ? new TextEncoder().encode(password) : password; // encode password as UTF-8
        const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8); // hash the password
        const ivStr = ciphertext.slice(0, 12);
        const iv = typeof ivStr === 'string' ? new Uint8Array(Array.from(ivStr).map(ch => ch.charCodeAt(0))) : ivStr; // decode base64 iv
        const alg = { name: 'AES-GCM', iv: iv }; // specify algorithm to use
        const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']); // generate key from pw
        const ctStr = ciphertext.slice(12);
        const ctUint8 = typeof ctStr === 'string' ? new Uint8Array(Array.from(ctStr).map(ch => ch.charCodeAt(0))) : ctStr;
        // note: why doesn't ctUint8 = new TextEncoder().encode(ctStr) work?
        try {
            const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8); // decrypt ciphertext using key
            return typeof ciphertext === 'string' ? new TextDecoder().decode(plainBuffer) : new Uint8Array(plainBuffer);
        }
        catch (e) {
            throw new Error('Decrypt failed');
        }
    }

    /**
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * Modified from: https://github.com/GoogleChromeLabs/text-editor/blob/main/src/inline-scripts/fs-helpers.js
     */
    /**
     * Open a handle to an existing file on the local file system.
     *
     * @return {!Promise<FileSystemFileHandle>} Handle to the existing file.
     */
    function getFileHandle() {
        // For Chrome 86 and later...
        if ('showOpenFilePicker' in window) {
            return window.showOpenFilePicker().then((handles) => handles[0]);
        }
        // For Chrome 85 and earlier...
        return window.chooseFileSystemEntries();
    }
    /**
     * Create a handle to a new (text) file on the local file system.
     *
     * @return {!Promise<FileSystemFileHandle>} Handle to the new file.
     */
    function getNewFileHandle() {
        // For Chrome 86 and later...
        if ('showSaveFilePicker' in window) {
            const opts = {
                types: [{
                        description: 'Text file',
                        accept: { 'text/plain': ['.txt'] },
                    }],
            };
            return window.showSaveFilePicker(opts);
        }
        // For Chrome 85 and earlier...
        const opts = {
            type: 'save-file',
            accepts: [{
                    description: 'Text file',
                    extensions: ['txt'],
                    mimeTypes: ['text/plain'],
                }],
        };
        return window.chooseFileSystemEntries(opts);
    }
    /**
     * Reads the raw text from a file.
     *
     * @param {File} file
     * @return {!Promise<string>} A promise that resolves to the parsed string.
     */
    function readFile(file) {
        // If the new .text() reader is available, use it.
        if (file.text) {
            return file.text();
        }
        // Otherwise use the traditional file reading technique.
        return _readFileLegacy(file);
    }
    /**
     * Reads the raw text from a file.
     *
     * @private
     * @param {File} file
     * @return {Promise<string>} A promise that resolves to the parsed string.
     */
    function _readFileLegacy(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.addEventListener('loadend', (e) => {
                const text = e.srcElement.result;
                resolve(text);
            });
            reader.readAsText(file);
        });
    }
    /**
     * Writes the contents to disk.
     *
     * @param {FileSystemFileHandle} fileHandle File handle to write to.
     * @param {string} contents Contents to write.
     */
    async function writeFile(fileHandle, contents) {
        // Support for Chrome 82 and earlier.
        if (fileHandle.createWriter) {
            // Create a writer (request permission if necessary).
            const writer = await fileHandle.createWriter();
            // Write the full length of the contents
            await writer.write(0, contents);
            // Close the file and write the contents to disk
            await writer.close();
            return;
        }
        // For Chrome 83 and later.
        // Create a FileSystemWritableFileStream to write to.
        const writable = await fileHandle.createWritable();
        // Write the contents of the file to the stream.
        await writable.write(contents);
        // Close the file and write the contents to disk.
        await writable.close();
    }
    /**
     * Verify the user has granted permission to read or write to the file, if
     * permission hasn't been granted, request permission.
     *
     * @param {FileSystemFileHandle} fileHandle File handle to check.
     * @param {boolean} withWrite True if write permission should be checked.
     * @return {boolean} True if the user has granted read/write permission.
     */
    async function verifyPermission(fileHandle, withWrite) {
        const opts = {};
        if (withWrite) {
            opts.writable = true;
            // For Chrome 86 and later...
            opts.mode = 'readwrite';
        }
        // Check if we already have permission, if so, return true.
        if (await fileHandle.queryPermission(opts) === 'granted') {
            return true;
        }
        // Request permission to the file, if the user grants permission, return true.
        if (await fileHandle.requestPermission(opts) === 'granted') {
            return true;
        }
        // The user did nt grant permission, return false.
        return false;
    }

    /**
     * Convert an image {@link ImageBitmap} or {@link CanvasImageSource} to a base64 data url.
     * @param bitmap - image to convert
     * @param maxWidth - maximum width of the image (default: 8192). Images larger than this will be scaled down. This is because strings can get too long.
     * @param detachBitmap - detach the bitmap after conversion (default: false). This will free up bitmap memory if you don't need it anymore.
     *
     * See also {@link imageUrlToImageData}
     *
     * @category Images
     */
    function imageBitmapToBase64(bitmap, maxWidth = 8192, detachBitmap = false) {
        var _a;
        if (!bitmap.width || !bitmap.height)
            return '';
        // create a canvas
        const canvas = document.createElement('canvas');
        // resize it to the size of our ImageBitmap
        canvas.width = Math.min(maxWidth, bitmap.width);
        canvas.height = Math.floor(1.0 + canvas.width * bitmap.height / bitmap.width);
        // try to get a bitmaprenderer context if same size
        const isBitmap = bitmap instanceof ImageBitmap;
        const ctx = isBitmap && detachBitmap && Math.abs(canvas.width - bitmap.width) < 0.5 ? canvas.getContext('bitmaprenderer') : undefined;
        if (ctx) {
            // transfer the ImageBitmap to it
            ctx.transferFromImageBitmap(bitmap); // less memory but it will detach the bitmap
        }
        else {
            // in case someone supports createImageBitmap only
            // twice in memory...
            (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        }
        // get it back as a Blob
        const url = canvas.toDataURL('image/png');
        canvas.remove();
        if (isBitmap && detachBitmap) {
            bitmap.close();
        }
        return url;
    }
    /**
     * Downloads/parse the image from an url/data url and draw to an {@link ImageData} object.
     * @param url - url or data url of the image
     * @returns ImageData object
     *
     * See also {@link imageBitmapToBase64}
     *
     * @category Images
     */
    async function imageUrlToImageData(url) {
        return new Promise((resolve, reject) => {
            const image = new Image();
            image.addEventListener('load', () => {
                const canvas = document.createElement('canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext('2d');
                if (!context) {
                    reject(new Error('Could not get 2d context'));
                    return;
                }
                context.drawImage(image, 0, 0, canvas.width, canvas.height);
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                resolve(imageData);
                // how do i return this?
                canvas.remove();
                image.remove();
            }, false);
            image.addEventListener('error', (e) => {
                image.remove();
                reject(e);
            }, false);
            image.src = url;
        });
    }
    /**
     * Converts an HTML image to a canvas. This creates a new canvas element and draws the image on it.
     * @param image - image to convert
     * @param backgroundColor - background color of the canvas
     * @param scale - scale of the canvas
     * @param width - width of the canvas
     * @param height - height of the canvas
     * @returns a new canvas element
     *
     * @category Images
     */
    function imageToCanvas(image, { backgroundColor = '', scale = 1, width = 512, height = 512, }) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const ratio = scale;
        const canvasWidth = width;
        const canvasHeight = height;
        canvas.width = canvasWidth * ratio;
        canvas.height = canvasHeight * ratio;
        canvas.style.width = `${canvasWidth}`;
        canvas.style.height = `${canvasHeight}`;
        if ((backgroundColor === null || backgroundColor === void 0 ? void 0 : backgroundColor.length) > 0) {
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
        }
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
        return canvas;
    }
    /**
     * Converts an {@link ImageData} to a canvas. This creates a new canvas element and draws the image data on it.
     * Image Data can be created from image pixels like from gl.readPixels
     * This can be used to convert a WebGL texture/render target to a canvas/data url.
     * Note: if the output is flipped, use {@link canvasFlipY} after this, like `canvasFlipY(imageDataToCanvas(imageData))`
     * @param data - image data to convert
     */
    function imageDataToCanvas(data) {
        const canvas = document.createElement('canvas');
        canvas.width = data.width;
        canvas.height = data.height;
        const context = canvas.getContext('2d');
        context.putImageData(data, 0, 0);
        return canvas;
    }
    /**
     * Check if the browser supports exporting to webp, with the canvas.toDataURL('image/webp') method.
     */
    function isWebpExportSupported() {
        const elem = document.createElement('canvas');
        if (elem.getContext && elem.getContext('2d')) {
            // was able or not to get WebP representation
            return elem.toDataURL('image/webp').startsWith('data:image/webp');
        }
        else {
            // very old browser like IE 8, canvas not supported
            return false;
        }
    }
    /**
     * Returns a new canvas with the image/canvas-content flipped vertically.
     * Useful for putImageData(as it does not respect scale and translate) and WebGL textures, which are flipped vertically.
     * @param canvas
     */
    function canvasFlipY(canvas) {
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvas.width;
        newCanvas.height = canvas.height;
        const ctx = newCanvas.getContext('2d');
        if (!ctx)
            throw new Error('Unable to get 2d context');
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
        ctx.drawImage(canvas, 0, 0);
        return newCanvas;
    }

    /**
     * Returns a data url for a 16x16 svg rectangle with the given color.
     * @param c - color
     *
     * @category SVGs
     */
    const makeColorSvg = (c) => {
        return `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${c}'/%3E%3C/svg%3E%0A`;
    };
    /**
     * Returns a data url for a 16x16 svg circle with the given color.
     * @param c - color
     *
     * @category SVGs
     */
    const makeColorSvgCircle = (c) => {
        return `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${c}'/%3E%3C/svg%3E%0A`;
    };
    /**
     * Returns a data url for a svg with the given text.
     * @param text
     *
     * @category SVGs
     */
    const makeTextSvg = (text) => {
        return `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${text}%3C/text%3E%3C/svg%3E%0A`;
    };
    /**
     * Renders an SVG to a canvas.
     * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
     * @param options - options
     *
     * @category SVGs
     */
    const svgToCanvas = async (svgDataUrl, options) => {
        const image = await createImage(svgDataUrl);
        return imageToCanvas(image, options);
    };
    /**
     * Renders an SVG to a png data url.
     * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
     * @param options - options
     *
     * @category SVGs
     */
    const svgToPng = async (svgDataUrl, options) => {
        return await svgToCanvas(svgDataUrl, options).then(canvas => canvas.toDataURL('image/png'));
    };

    const defaultDownloader = async (url) => blobToDataURL(await (await fetch(url)).blob());
    /**
     * Find all URLs in svg, download them and replace with the URL in svg with the downloaded data URLs.
     * @param str - string
     * @param downloader - function to download the URLs in svg and return the data URL
     *
     * @category HTML To Image
     */
    async function embedUrlRefs(str, downloader = defaultDownloader) {
        const urls = str.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
        if (urls) {
            for (const url of urls) {
                const dataUrl = await downloader(url);
                str = str.replace(url, dataUrl);
            }
        }
        return str;
    }
    /**
     * Embeds an HTML string into a svg tag and converts to svg string or svg as data url
     * @param html - HTML string
     * @param style - CSS string
     * @param width - width of the svg
     * @param height - height of the svg
     * @param toDataUrl - if true, returns a data url, otherwise returns the svg string
     * @returns svg string or svg as data url
     *
     * @category HTML To Image
     */
    function htmlToSvg(html, style, { width, height }, toDataUrl = true) {
        const s = `
<svg viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${style}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${html}
        </div>
    </foreignObject>
</svg>
    `;
        return toDataUrl ? svgUrl(s) : s;
    }
    /**
     * Renders an HTML string to a canvas. This is done by first embedding HTML into a svg and then rendering the svg to a canvas.
     * @param html - HTML string
     * @param style - CSS string
     * @param options - options for rendering the canvas
     * @returns HTML canvas element
     *
     * @category HTML To Image
     */
    async function htmlToCanvas(html, style, options) {
        const svg = htmlToSvg(html, style, options);
        return await svgToCanvas(svg, options);
    }
    /**
     * Renders an HTML string to a png. This is done by first embedding HTML into a svg and then rendering the svg to a png.
     * @param html
     * @param style
     * @param options
     * @returns png as data url
     *
     * @category HTML To Image
     */
    async function htmlToPng(html, style, options) {
        const svg = htmlToSvg(html, style, options);
        return await svgToPng(svg, options);
    }

    /**
     * Returns the number which is larger in absolute value.
     * @param a
     * @param b
     *
     * @category Maths
     */
    function absMax(a, b) {
        return Math.abs(a) > Math.abs(b) ? a : b;
    }
    /**
     * Updates the bit at the given position to the given value.
     * @param number - the number to update
     * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
     * @param bitValue - 0 or 1
     */
    function updateBit(number, bitPosition, bitValue) {
        const bitValueNormalized = bitValue ? 1 : 0;
        const clearMask = ~(1 << bitPosition);
        return (number & clearMask) | (bitValueNormalized << bitPosition);
    }
    /**
     * Clears the bit at the given position.
     * @param number - the number to update
     * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
     */
    function clearBit(number, bitPosition) {
        const clearMask = ~(1 << bitPosition);
        return number & clearMask;
    }

    /**
     * Access property in an object using a string path. Similar to lodash.get
     * @param access - path to access
     * @param tar - target object
     * @param throwOnInvalid - throw error if invalid access or property is undefined. Default is false
     *
     * @example
     * ```js
     * const obj = {a: {b: {c: 1}}}
     * const c = deepAccessObject(['a', 'b', 'c'], obj)
     * console.log(c) // 1
     * ```
     *
     * @category JS Object
     */
    function deepAccessObject(access, tar, throwOnInvalid = false) {
        if (typeof access === 'string')
            access = access.split('.');
        while (access.length > 0) {
            if (!tar)
                return;
            const p = access.splice(0, 1)[0];
            if (p.length < 1)
                continue;
            if (p in tar) {
                tar = tar[p];
            }
            else {
                // console.error('invalid access, check', p, tar)
                if (throwOnInvalid)
                    throw new Error('invalid access, check ' + p + ' in ' + tar);
                else
                    return undefined;
                // return tar
            }
        }
        return tar;
    }
    /**
     * Find the key of an object with a given value.
     * @param object - object to search
     * @param value - value to search for
     *
     * @category JS Object
     */
    function getKeyByValue(object, value) {
        return Object.keys(object).find(key => object[key] === value);
    }
    /**
     * Check if an object has a property. Same as {@link Object.hasOwn} or {@link Object.hasOwnProperty}
     * @param o
     * @param v
     */
    function objectHasOwn(o, v) {
        return Object.hasOwn ? Object.hasOwn(o, v) : o.hasOwnProperty(v);
    }

    /**
     * Get URL query parameter. If not found, return default value. Similar to PHP's $_GET
     * @param p - parameter name to get
     * @param def - default value if parameter not found
     *
     * @category URL
     */
    function getUrlQueryParam(p, def = null) {
        var _a;
        const url = new URL(window.location.href);
        return (_a = url.searchParams.get(p)) !== null && _a !== void 0 ? _a : def;
    }
    /**
     * Set URL query parameter. If value is null, remove parameter. Similar to PHP's $_GET
     * @param p - parameter name to set
     * @param v - parameter value or null to remove
     * @param reload - reload page after setting parameter, default false. If false, `history.replaceState` is used.
     *
     * @category URL
     */
    function setUrlQueryParam(p, v, reload = false) {
        const params = new URLSearchParams(location.search);
        if (v === null || v === undefined) {
            if (params.has(p))
                params.delete(p);
        }
        else
            params.set(p, v);
        if (!reload)
            window.history.replaceState({}, '', '?' + params.toString()); // todo: check if default state and set to /
        else
            window.location.search = params.toString();
    }
    /**
     * Join path parts with separator. Similar to PHP's pathJoin
     * @param parts - path parts
     * @param separator - separator, default '/'
     */
    function pathJoin(parts, separator = '/') {
        // const replace = new RegExp(separator + '{1,}', 'g')
        return parts.join(separator); // .replace(replace, separator) //todo fix: replace breaks https://raw to https:/raw
    }
    /**
     * Returns a blob:// URL which points to a javascript file which will call importScripts with the given URL, to be used for cross-origin workers.
     * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     * @param url - URL to the worker js file
     * @param wasmURL - optional wasm file URL, will be passed to a created Module.locateFile (for emscripten)
     */
    function remoteWorkerURL(url, wasmURL) {
        const content = (wasmURL ? `var Module = { locateFile: function(s) { return "${wasmURL}"; } }; \n` : '')
            + `importScripts( "${url}" );`;
        return URL.createObjectURL(new Blob([content], { type: 'text/javascript' }));
    }

    exports.Damper = Damper;
    exports.LinearToSRGB = LinearToSRGB;
    exports.PointerDragHelper = PointerDragHelper;
    exports.SRGBToLinear = SRGBToLinear;
    exports.Serialization = Serialization;
    exports.SimpleEventDispatcher = SimpleEventDispatcher;
    exports.TYPED_ARRAYS = TYPED_ARRAYS;
    exports.absMax = absMax;
    exports.aesGcmDecrypt = aesGcmDecrypt;
    exports.aesGcmEncrypt = aesGcmEncrypt;
    exports.arrayBufferToBase64 = arrayBufferToBase64;
    exports.base64ToArrayBuffer = base64ToArrayBuffer;
    exports.blobToDataURL = blobToDataURL;
    exports.canvasFlipY = canvasFlipY;
    exports.clearBit = clearBit;
    exports.colorToDataUrl = colorToDataUrl;
    exports.copyProps = copyProps;
    exports.createCanvasElement = createCanvasElement;
    exports.createDiv = createDiv;
    exports.createImage = createImage;
    exports.createScriptFromURL = createScriptFromURL;
    exports.createStyles = createStyles;
    exports.css = css;
    exports.deepAccessObject = deepAccessObject;
    exports.downloadBlob = downloadBlob;
    exports.downloadFile = downloadFile;
    exports.embedUrlRefs = embedUrlRefs;
    exports.escapeRegExp = escapeRegExp;
    exports.getFileHandle = getFileHandle;
    exports.getFilenameFromPath = getFilenameFromPath;
    exports.getKeyByValue = getKeyByValue;
    exports.getNewFileHandle = getNewFileHandle;
    exports.getOrCall = getOrCall;
    exports.getPropertyDescriptor = getPropertyDescriptor;
    exports.getTypedArray = getTypedArray;
    exports.getUrlQueryParam = getUrlQueryParam;
    exports.glsl = glsl;
    exports.html = html;
    exports.htmlToCanvas = htmlToCanvas;
    exports.htmlToPng = htmlToPng;
    exports.htmlToSvg = htmlToSvg;
    exports.imageBitmapToBase64 = imageBitmapToBase64;
    exports.imageDataToCanvas = imageDataToCanvas;
    exports.imageToCanvas = imageToCanvas;
    exports.imageUrlToImageData = imageUrlToImageData;
    exports.includesAll = includesAll;
    exports.isPropertyWritable = isPropertyWritable;
    exports.isWebpExportSupported = isWebpExportSupported;
    exports.longestCommonPrefix = longestCommonPrefix;
    exports.makeColorSvg = makeColorSvg;
    exports.makeColorSvgCircle = makeColorSvgCircle;
    exports.makeTextSvg = makeTextSvg;
    exports.mobileAndTabletCheck = mobileAndTabletCheck;
    exports.now = now;
    exports.objectHasOwn = objectHasOwn;
    exports.onChange = onChange;
    exports.onChange2 = onChange2;
    exports.onChange3 = onChange3;
    exports.parseFileExtension = parseFileExtension;
    exports.pathJoin = pathJoin;
    exports.prettyScrollbar = prettyScrollbar;
    exports.readFile = readFile;
    exports.remoteWorkerURL = remoteWorkerURL;
    exports.replaceAll = replaceAll;
    exports.safeSetProperty = safeSetProperty;
    exports.serializable = serializable;
    exports.serialize = serialize;
    exports.setUrlQueryParam = setUrlQueryParam;
    exports.svgToCanvas = svgToCanvas;
    exports.svgToPng = svgToPng;
    exports.svgUrl = svgUrl;
    exports.timeout = timeout;
    exports.toTitleCase = toTitleCase;
    exports.updateBit = updateBit;
    exports.uploadFile = uploadFile;
    exports.verifyPermission = verifyPermission;
    exports.writeFile = writeFile;

}));
//# sourceMappingURL=bundle.umd.js.map
